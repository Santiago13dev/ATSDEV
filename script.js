class ATSDetector {\n    constructor() {\n        this.initializeEventListeners();\n        this.atsChecks = [\n            { name: 'formatoArchivo', weight: 15, description: 'Formato de archivo compatible' },\n            { name: 'informacionContacto', weight: 20, description: 'Información de contacto completa' },\n            { name: 'estructuraSeciones', weight: 20, description: 'Estructura y secciones claras' },\n            { name: 'palabrasClave', weight: 15, description: 'Palabras clave relevantes' },\n            { name: 'formatoFechas', weight: 10, description: 'Formato de fechas estándar' },\n            { name: 'elementosProblematicos', weight: 10, description: 'Sin elementos problemáticos' },\n            { name: 'longitudTexto', weight: 10, description: 'Longitud apropiada del CV' }\n        ];\n\n        this.seccionesEsperadas = [\n            'experiencia', 'educación', 'habilidades', 'contacto', \n            'perfil', 'resumen', 'objetivo', 'competencias'\n        ];\n\n        this.palabrasClaveComunes = [\n            'gestión', 'desarrollo', 'análisis', 'implementación', 'liderazgo',\n            'comunicación', 'trabajo en equipo', 'resolución de problemas',\n            'planificación', 'organización', 'creatividad', 'innovación'\n        ];\n    }\n\n    initializeEventListeners() {\n        const fileInput = document.getElementById('fileInput');\n        const uploadArea = document.getElementById('uploadArea');\n\n        if (!fileInput || !uploadArea) {\n            console.error('Elementos HTML requeridos no encontrados');\n            return;\n        }\n\n        // Event listeners para el input de archivo\n        fileInput.addEventListener('change', (e) => this.handleFileSelect(e));\n        \n        // Event listeners para drag and drop\n        uploadArea.addEventListener('dragover', (e) => {\n            e.preventDefault();\n            uploadArea.classList.add('dragover');\n        });\n\n        uploadArea.addEventListener('dragleave', () => {\n            uploadArea.classList.remove('dragover');\n        });\n\n        uploadArea.addEventListener('drop', (e) => {\n            e.preventDefault();\n            uploadArea.classList.remove('dragover');\n            const files = e.dataTransfer.files;\n            if (files.length > 0) {\n                this.processFile(files[0]);\n            }\n        });\n\n        uploadArea.addEventListener('click', () => {\n            fileInput.click();\n        });\n    }\n\n    handleFileSelect(event) {\n        const file = event.target.files[0];\n        if (file) {\n            this.processFile(file);\n        }\n    }\n\n    async processFile(file) {\n        try {\n            this.showProcessing();\n            \n            let text = '';\n            if (file.type === 'application/pdf') {\n                text = await this.extractTextFromPDF(file);\n            } else if (file.type === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document') {\n                text = await this.extractTextFromDOCX(file);\n            } else {\n                throw new Error('Formato de archivo no soportado');\n            }\n\n            const analysis = this.analyzeCV(text, file);\n            this.displayResults(analysis);\n\n        } catch (error) {\n            console.error('Error procesando archivo:', error);\n            this.showError('Error al procesar el archivo. Por favor, intenta con otro formato.');\n        }\n    }\n\n    async extractTextFromPDF(file) {\n        return new Promise((resolve, reject) => {\n            const reader = new FileReader();\n            reader.onload = async function(e) {\n                try {\n                    const typedarray = new Uint8Array(e.target.result);\n                    const pdf = await pdfjsLib.getDocument(typedarray).promise;\n                    let text = '';\n                    \n                    for (let i = 1; i <= pdf.numPages; i++) {\n                        const page = await pdf.getPage(i);\n                        const textContent = await page.getTextContent();\n                        text += textContent.items.map(item => item.str).join(' ') + '\\n';\n                    }\n                    \n                    resolve(text);\n                } catch (error) {\n                    reject(error);\n                }\n            };\n            reader.onerror = reject;\n            reader.readAsArrayBuffer(file);\n        });\n    }\n\n    async extractTextFromDOCX(file) {\n        return new Promise((resolve, reject) => {\n            const reader = new FileReader();\n            reader.onload = function(e) {\n                mammoth.extractRawText({arrayBuffer: e.target.result})\n                    .then(result => resolve(result.value))\n                    .catch(reject);\n            };\n            reader.onerror = reject;\n            reader.readAsArrayBuffer(file);\n        });\n    }\n\n    analyzeCV(text, file) {\n        const results = {};\n        let totalScore = 0;\n\n        // Análisis de cada criterio\n        this.atsChecks.forEach(check => {\n            const result = this[check.name](text, file);\n            results[check.name] = {\n                ...result,\n                weight: check.weight,\n                description: check.description\n            };\n            totalScore += result.score * (check.weight / 100);\n        });\n\n        return {\n            totalScore: Math.round(totalScore),\n            checks: results,\n            recommendations: this.generateRecommendations(results)\n        };\n    }\n\n    formatoArchivo(text, file) {\n        const supportedFormats = ['application/pdf', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'];\n        const isSupported = supportedFormats.includes(file.type);\n        \n        return {\n            score: isSupported ? 100 : 0,\n            status: isSupported ? 'passed' : 'failed',\n            message: isSupported ? \n                `Formato ${file.type.includes('pdf') ? 'PDF' : 'DOCX'} compatible con ATS` :\n                'Formato no compatible. Usa PDF o DOCX',\n            details: isSupported ? \n                'Los formatos PDF y DOCX son fácilmente leíbles por sistemas ATS' :\n                'Evita formatos como JPG, PNG o DOC (versión antigua)'\n        };\n    }\n\n    informacionContacto(text) {\n        const emailRegex = /\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b/;\n        const phoneRegex = /(?:\\+?\\d{1,3}[-.\\s]?)?\\(?\\d{3}\\)?[-.\\s]?\\d{3}[-.\\s]?\\d{4}/;\n        \n        const hasEmail = emailRegex.test(text);\n        const hasPhone = phoneRegex.test(text);\n        \n        let score = 0;\n        if (hasEmail) score += 50;\n        if (hasPhone) score += 50;\n        \n        const status = score >= 100 ? 'passed' : score >= 50 ? 'warning' : 'failed';\n        \n        return {\n            score,\n            status,\n            message: `Información de contacto: ${hasEmail ? '✓ Email' : '✗ Email'} ${hasPhone ? '✓ Teléfono' : '✗ Teléfono'}`,\n            details: score < 100 ? 'Incluye al menos email y teléfono en la parte superior del CV' : 'Información de contacto completa'\n        };\n    }\n\n    estructuraSeciones(text) {\n        const textLower = text.toLowerCase();\n        let sectionsFound = 0;\n        const foundSections = [];\n        \n        this.seccionesEsperadas.forEach(section => {\n            if (textLower.includes(section)) {\n                sectionsFound++;\n                foundSections.push(section);\n            }\n        });\n        \n        const score = Math.min(100, (sectionsFound / 4) * 100);\n        const status = score >= 75 ? 'passed' : score >= 50 ? 'warning' : 'failed';\n        \n        return {\n            score,\n            status,\n            message: `${sectionsFound} secciones identificadas: ${foundSections.slice(0, 3).join(', ')}${foundSections.length > 3 ? '...' : ''}`,\n            details: score < 75 ? 'Asegúrate de incluir secciones claras como Experiencia, Educación, Habilidades' : 'Estructura de secciones adecuada'\n        };\n    }\n\n    palabrasClave(text) {\n        const textLower = text.toLowerCase();\n        let keywordsFound = 0;\n        const foundKeywords = [];\n        \n        this.palabrasClaveComunes.forEach(keyword => {\n            if (textLower.includes(keyword)) {\n                keywordsFound++;\n                foundKeywords.push(keyword);\n            }\n        });\n        \n        const score = Math.min(100, (keywordsFound / 6) * 100);\n        const status = score >= 60 ? 'passed' : score >= 30 ? 'warning' : 'failed';\n        \n        return {\n            score,\n            status,\n            message: `${keywordsFound} palabras clave encontradas`,\n            details: score < 60 ? 'Incluye más palabras clave relevantes para tu industria' : 'Buen uso de palabras clave profesionales'\n        };\n    }\n\n    formatoFechas(text) {\n        const dateRegex = /(\\d{4})|(\\d{1,2}\\/\\d{4})|(\\d{1,2}\\/\\d{1,2}\\/\\d{4})/g;\n        const dates = text.match(dateRegex) || [];\n        \n        const score = dates.length >= 2 ? 100 : dates.length >= 1 ? 70 : 0;\n        const status = score >= 70 ? 'passed' : score >= 40 ? 'warning' : 'failed';\n        \n        return {\n            score,\n            status,\n            message: `${dates.length} fechas encontradas`,\n            details: score < 70 ? 'Incluye fechas claras en experiencia y educación (MM/AAAA)' : 'Formato de fechas adecuado'\n        };\n    }\n\n    elementosProblematicos(text, file) {\n        let problems = [];\n        let score = 100;\n        \n        // Verificar longitud excesiva de líneas (posibles tablas)\n        const lines = text.split('\\n');\n        const longLines = lines.filter(line => line.length > 200);\n        if (longLines.length > 3) {\n            problems.push('Posibles tablas o formatos complejos detectados');\n            score -= 30;\n        }\n        \n        // Verificar caracteres especiales problemáticos\n        const problematicChars = /[│┤├┼┴┬]/g;\n        if (problematicChars.test(text)) {\n            problems.push('Caracteres de tabla detectados');\n            score -= 20;\n        }\n        \n        // Verificar texto muy corto (posible imagen)\n        if (text.trim().length < 500) {\n            problems.push('Contenido muy corto, posible CV en imagen');\n            score -= 50;\n        }\n        \n        const status = score >= 80 ? 'passed' : score >= 50 ? 'warning' : 'failed';\n        \n        return {\n            score: Math.max(0, score),\n            status,\n            message: problems.length === 0 ? 'Sin elementos problemáticos detectados' : `${problems.length} problema(s) detectado(s)`,\n            details: problems.length === 0 ? 'CV libre de elementos que dificultan la lectura ATS' : problems.join(', ')\n        };\n    }\n\n    longitudTexto(text) {\n        const wordCount = text.trim().split(/\\s+/).length;\n        let score = 0;\n        \n        if (wordCount >= 300 && wordCount <= 800) {\n            score = 100;\n        } else if (wordCount >= 200 && wordCount <= 1000) {\n            score = 80;\n        } else if (wordCount >= 150 && wordCount <= 1200) {\n            score = 60;\n        } else {\n            score = 30;\n        }\n        \n        const status = score >= 80 ? 'passed' : score >= 60 ? 'warning' : 'failed';\n        \n        return {\n            score,\n            status,\n            message: `${wordCount} palabras (Óptimo: 300-800)`,\n            details: wordCount < 300 ? 'CV muy corto, agrega más detalles relevantes' :\n                    wordCount > 800 ? 'CV muy extenso, considera reducir información menos relevante' :\n                    'Longitud adecuada para un CV'\n        };\n    }\n\n    generateRecommendations(results) {\n        const recommendations = [];\n        \n        Object.entries(results).forEach(([key, result]) => {\n            if (result.score < 70) {\n                let recommendation = {\n                    title: result.description,\n                    description: result.details\n                };\n                \n                // Recomendaciones específicas por categoría\n                switch (key) {\n                    case 'formatoArchivo':\n                        recommendation.action = 'Guarda tu CV como PDF o DOCX para garantizar compatibilidad';\n                        break;\n                    case 'informacionContacto':\n                        recommendation.action = 'Añade email y teléfono en la parte superior del CV';\n                        break;\n                    case 'estructuraSeciones':\n                        recommendation.action = 'Organiza tu CV con secciones claras: Contacto, Resumen, Experiencia, Educación, Habilidades';\n                        break;\n                    case 'palabrasClave':\n                        recommendation.action = 'Incluye palabras clave específicas de tu industria y el puesto al que aplicas';\n                        break;\n                    case 'formatoFechas':\n                        recommendation.action = 'Usa formato MM/AAAA para fechas (ej: 01/2020 - 12/2022)';\n                        break;\n                    case 'elementosProblematicos':\n                        recommendation.action = 'Evita tablas, gráficos, imágenes y usa formato simple con texto plano';\n                        break;\n                    case 'longitudTexto':\n                        recommendation.action = result.score < 50 ? 'Amplía tu CV con más detalles de experiencia y logros' : 'Reduce el contenido, mantén solo lo más relevante';\n                        break;\n                }\n                \n                recommendations.push(recommendation);\n            }\n        });\n        \n        // Recomendaciones generales si el score es bajo\n        if (Object.values(results).reduce((acc, r) => acc + r.score * (r.weight / 100), 0) < 60) {\n            recommendations.push({\n                title: 'Optimización general ATS',\n                description: 'Tu CV necesita mejoras importantes para ser compatible con sistemas ATS',\n                action: 'Enfócate primero en el formato de archivo, información de contacto y estructura clara de secciones'\n            });\n        }\n        \n        return recommendations;\n    }\n\n    showProcessing() {\n        const resultsSection = document.getElementById('resultsSection');\n        if (!resultsSection) {\n            console.error('Elemento resultsSection no encontrado');\n            return;\n        }\n        \n        resultsSection.style.display = 'block';\n        resultsSection.innerHTML = `\n            <div class=\"processing\">\n                <div class=\"spinner\"></div>\n                <h3>Analizando tu CV...</h3>\n                <p>Verificando compatibilidad con sistemas ATS</p>\n            </div>\n        `;\n    }\n\n    showError(message) {\n        const resultsSection = document.getElementById('resultsSection');\n        if (!resultsSection) {\n            console.error('Elemento resultsSection no encontrado');\n            alert(message); // Fallback para mostrar el error\n            return;\n        }\n        \n        resultsSection.style.display = 'block';\n        resultsSection.innerHTML = `\n            <div class=\"check-item failed\">\n                <span class=\"check-icon\">❌</span>\n                <div class=\"check-text\">\n                    <strong>Error</strong>\n                    <small>${message}</small>\n                </div>\n            </div>\n        `;\n    }\n\n    displayResults(analysis) {\n        // Recrear la estructura HTML si no existe\n        this.ensureResultsStructure();\n        \n        // Actualizar score circle\n        this.updateScoreCircle(analysis.totalScore);\n        \n        // Mostrar análisis detallado\n        this.displayAnalysisResults(analysis.checks);\n        \n        // Mostrar recomendaciones\n        this.displayRecommendations(analysis.recommendations);\n        \n        // Mostrar la sección de resultados\n        const resultsSection = document.getElementById('resultsSection');\n        if (resultsSection) {\n            resultsSection.style.display = 'block';\n        }\n    }\n\n    ensureResultsStructure() {\n        const resultsSection = document.getElementById('resultsSection');\n        if (!resultsSection) {\n            console.error('Elemento resultsSection no encontrado');\n            return;\n        }\n\n        // Verificar si ya existe la estructura, si no, crearla\n        if (!document.getElementById('scoreCircle')) {\n            resultsSection.innerHTML = `\n                <div class=\"score-card\">\n                    <div class=\"score-circle\" id=\"scoreCircle\">\n                        <span id=\"scoreValue\">0</span>\n                        <small>/ 100</small>\n                    </div>\n                    <h3 id=\"scoreStatus\">Procesando...</h3>\n                </div>\n\n                <div class=\"analysis-results\">\n                    <h3>📊 Análisis detallado</h3>\n                    <div id=\"analysisResults\"></div>\n                </div>\n\n                <div class=\"recommendations\">\n                    <h3>💡 Recomendaciones</h3>\n                    <div id=\"recommendationsList\"></div>\n                </div>\n            `;\n        }\n    }\n\n    updateScoreCircle(score) {\n        const scoreCircle = document.getElementById('scoreCircle');\n        const scoreValue = document.getElementById('scoreValue');\n        const scoreStatus = document.getElementById('scoreStatus');\n        \n        if (!scoreCircle || !scoreValue || !scoreStatus) {\n            console.error('Elementos del score circle no encontrados');\n            return;\n        }\n\n        // Actualizar valor\n        scoreValue.textContent = score;\n        \n        // Actualizar color y mensaje según score\n        let color, status;\n        if (score >= 80) {\n            color = '#4CAF50';\n            status = '¡Excelente compatibilidad ATS!';\n        } else if (score >= 60) {\n            color = '#FF9800';\n            status = 'Buena compatibilidad ATS';\n        } else if (score >= 40) {\n            color = '#FF5722';\n            status = 'Compatibilidad ATS mejorable';\n        } else {\n            color = '#F44336';\n            status = 'Baja compatibilidad ATS';\n        }\n        \n        // Actualizar círculo con animación\n        const percentage = (score / 100) * 360;\n        scoreCircle.style.background = `conic-gradient(${color} ${percentage}deg, #e0e0e0 ${percentage}deg)`;\n        scoreStatus.textContent = status;\n        scoreStatus.style.color = color;\n    }\n\n    displayAnalysisResults(checks) {\n        const analysisResults = document.getElementById('analysisResults');\n        if (!analysisResults) {\n            console.error('Elemento analysisResults no encontrado');\n            return;\n        }\n        \n        let html = '';\n        \n        Object.entries(checks).forEach(([key, check]) => {\n            const icon = check.status === 'passed' ? '✅' : \n                        check.status === 'warning' ? '⚠️' : '❌';\n            \n            html += `\n                <div class=\"check-item ${check.status}\">\n                    <span class=\"check-icon\">${icon}</span>\n                    <div class=\"check-text\">\n                        <strong>${check.message}</strong>\n                        <small>${check.details}</small>\n                    </div>\n                </div>\n            `;\n        });\n        \n        analysisResults.innerHTML = html;\n    }\n\n    displayRecommendations(recommendations) {\n        const recommendationsList = document.getElementById('recommendationsList');\n        if (!recommendationsList) {\n            console.error('Elemento recommendationsList no encontrado');\n            return;\n        }\n        \n        if (recommendations.length === 0) {\n            recommendationsList.innerHTML = `\n                <div class=\"recommendation-item\">\n                    <h4>🎉 ¡Felicitaciones!</h4>\n                    <p>Tu CV tiene excelente compatibilidad con sistemas ATS. No necesitas realizar cambios importantes.</p>\n                </div>\n            `;\n            return;\n        }\n        \n        let html = '';\n        recommendations.forEach(rec => {\n            html += `\n                <div class=\"recommendation-item\">\n                    <h4>${rec.title}</h4>\n                    <p>${rec.description}</p>\n                    ${rec.action ? `<p><strong>Acción sugerida:</strong> ${rec.action}</p>` : ''}\n                </div>\n            `;\n        });\n        \n        recommendationsList.innerHTML = html;\n    }\n}\n\n// Configurar PDF.js worker\nif (typeof pdfjsLib !== 'undefined') {\n    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';\n}\n\n// Inicializar la aplicación cuando se carga la página\ndocument.addEventListener('DOMContentLoaded', () => {\n    new ATSDetector();\n});